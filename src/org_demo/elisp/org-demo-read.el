;;; org-demo-read.el --- Parse a demo document and return its entries as JSON  -*- lexical-binding: t; -*-

;; Reads an org-mode demo file and returns a JSON array of entries.
;; Each entry is an object with a "type" field ("note", "exec", "image")
;; plus type-specific fields.
;; Parameters: {{file}}

(progn
  (require 'json)
  (require 'org)
  (let* ((file (expand-file-name "{{file}}"))
         (entries '()))
    (with-temp-buffer
      (insert-file-contents file)
      (org-mode)
      (goto-char (point-min))
      (let ((title "")
            (uuid "")
            (date ""))
        (when (re-search-forward "^#\\+TITLE:\\s-*\\(.*\\)$" nil t)
          (setq title (match-string 1)))
        (goto-char (point-min))
        (when (re-search-forward "^#\\+PROPERTY:\\s-*org-demo-id\\s-+\\(.*\\)$" nil t)
          (setq uuid (match-string 1)))
        (goto-char (point-min))
        (when (re-search-forward "^#\\+DATE:\\s-*\\(.*\\)$" nil t)
          (setq date (match-string 1)))

        (goto-char (point-min))
        (while (and (not (eobp))
                    (looking-at-p "^#\\+"))
          (forward-line 1))
        (while (and (not (eobp)) (looking-at-p "^$"))
          (forward-line 1))

        (let ((current-name nil))
          (while (not (eobp))
            (cond
             ((looking-at "^#\\+NAME:\\s-*\\(.*\\)$")
              (setq current-name (match-string 1))
              (forward-line 1))

             ((looking-at "^#\\+BEGIN_SRC\\s-+\\(\\S-+\\)")
              (let ((lang (match-string 1))
                    (name (or current-name ""))
                    (code "")
                    (output ""))
                (setq current-name nil)
                (forward-line 1)
                (let ((code-start (point)))
                (if (re-search-forward "^#\\+END_SRC" nil t)
                    (progn
                      (beginning-of-line)
                      (setq code (buffer-substring-no-properties code-start (point)))
                      (forward-line 1))
                  (goto-char (point-max))))
              (while (and (not (eobp)) (looking-at-p "^$"))
                (forward-line 1))
              (when (looking-at-p "^#\\+RESULTS:")
                (forward-line 1)
                (cond
                 ;; EXAMPLE block format
                 ((looking-at-p "^#\\+BEGIN_EXAMPLE")
                  (forward-line 1)
                  (let ((out-start (point)))
                    (if (re-search-forward "^#\\+END_EXAMPLE" nil t)
                        (progn
                          (beginning-of-line)
                          (setq output (buffer-substring-no-properties out-start (point)))
                          (forward-line 1))
                      (goto-char (point-max)))))
                 ;; Colon-prefixed scalar output (": line")
                 ((looking-at-p "^: ")
                  (let ((lines '()))
                    (while (and (not (eobp)) (looking-at "^: \\(.*\\)$"))
                      (push (match-string 1) lines)
                      (forward-line 1))
                    (setq output (mapconcat #'identity (nreverse lines) "\n"))))))
              (when (string-suffix-p "\n" code)
                (setq code (substring code 0 -1)))
              (when (string-suffix-p "\n" output)
                (setq output (substring output 0 -1)))
              (push (list (cons "type" "exec")
                          (cons "lang" lang)
                          (cons "name" name)
                          (cons "code" code)
                          (cons "output" output))
                    entries)))

             ((looking-at "^# image:")
              (setq current-name nil)
              (forward-line 1)
              (let ((alt "")
                    (path ""))
              (when (looking-at "^\\[\\[file:\\([^]]+\\)\\]\\(?:\\[\\([^]]*\\)\\]\\)?\\]")
                (setq path (match-string 1))
                (setq alt (or (match-string 2) ""))
                (forward-line 1))
              (push (list (cons "type" "image")
                          (cons "path" path)
                          (cons "alt" alt))
                    entries)))

             ((looking-at-p "^$")
              (forward-line 1))

             (t
              (setq current-name nil)
              (let ((text-start (point)))
                (while (and (not (eobp))
                            (not (looking-at-p "^$"))
                          (not (looking-at-p "^#\\+"))
                          (not (looking-at-p "^# image:"))
                          (not (looking-at-p "^\\[\\[")))
                (forward-line 1))
              (let ((text (buffer-substring-no-properties text-start (point))))
                (when (string-suffix-p "\n" text)
                  (setq text (substring text 0 -1)))
                (push (list (cons "type" "note")
                            (cons "text" text))
                      entries))))))

        (let ((result (list (cons "title" title)
                            (cons "uuid" uuid)
                            (cons "date" date)
                            (cons "entries" (vconcat (nreverse entries))))))
          (json-encode result)))))))
